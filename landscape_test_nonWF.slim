// Keywords: continuous space, continuous spatial landscape, spatial map, reprising boundaries, QTL, quantitative trait loci, spatial competition, spatial mate choice

initialize() {
	initializeSLiMModelType("nonWF");

	defineConstant("sigma_C", 0.1);
	defineConstant("sigma_K", 0.5);
	defineConstant("sigma_M", 0.1);
	
	defineConstant("p1_opt", 0.0);
	defineConstant("p2_opt", 1.0);
	defineConstant("phen_weight", 2.0); //scales rel impact of pheno optimum on abs fitness
	
	defineConstant("rate_change", 1000);
	defineConstant("mig_rate", 0.1);
	defineConstant("N", 10);
	defineConstant("K", 10); //carrying capacity for pop
	
	initializeSLiMOptions(dimensionality="xyz");
	initializeMutationRate(1e-6);
	initializeMutationType("m1", 0.5, "f", 0.0);        // neutral
	initializeMutationType("m2", 0.5, "n", 0.0, 1.0);   // QTL
	m2.convertToSubstitution = F;
	
	initializeGenomicElementType("g1", c(m1, m2), c(1, 0.1));
	initializeGenomicElement(g1, 0, 1e5 - 1);
	initializeRecombinationRate(1e-8);
	
	
	initializeInteractionType(1, "xyz", reciprocal=T, maxDistance=sigma_C * 3);     // competition
	i1.setInteractionFunction("n", 1.0, sigma_C);
	initializeInteractionType(2, "xyz", reciprocal=T, maxDistance=sigma_M * 3);     // mate choice
	i2.setInteractionFunction("n", 1.0, sigma_M);
}

//random mate choice right now, need to change to weight by spatial proximity
reproduction() //called per ind, opportunity to mate
{
	// choose our nearest neighbor as a mate, within the max distance
	mate = i2.nearestNeighbors(individual, 1);
	for (i in seqLen(rpois(1, 0.1)))
 	{
		if (mate.size())
			offspring = subpop.addCrossed(individual, mate);
		else
			offspring = subpop.addSelfed(individual);

		// set offspring position
		do{
			pos = individual.spatialPosition[0:1] + rnorm(2, 0, 0.005);
		}while (p1.pointInBounds(c(pos,0.0)));
		
		phenotype = offspring.sumOfMutationsOfType(m2);
		offspring.setSpatialPosition(c(pos,phenotype));
	}
}

1 early() {
	sim.addSubpop("p1", N);
	sim.addSubpop("p2", N);
	
	p1.setSpatialBounds(c(0.0, 0.0, 0.0, 1.0, 1.0, 1.0));
	p2.setSpatialBounds(c(0.0, 0.0, 0.0, 1.0, 1.0, 1.0));
	
	defineConstant("mapValues", runif(25, -0.2, 1.2));
	p1.defineSpatialMap("map1", "xy", c(5, 5), mapValues, interpolate=T,
		valueRange=c(-0.2, 1.2), colors=c("red", "yellow"));
	p2.defineSpatialMap("map1", "xy", c(5, 5), mapValues, interpolate=T,
		valueRange=c(-0.2, 1.2), colors=c("red", "yellow"));
	
	for (ind in p1.individuals)
		ind.setSpatialPosition(p1.pointUniform());
	for (ind in p2.individuals)
		ind.setSpatialPosition(p2.pointUniform());
	p1.individuals.z = 0.0;
	p2.individuals.z = 0.0;
}

early() {
	p1.fitnessScaling = K / p1.individualCount;
	p2.fitnessScaling = K / p2.individualCount;
}

//early() {
	//fitness(NULL) {    // phenotypic competition
	//	totalStrength = sum(i1.strength(individual));
	//	totalInd = p1.individualCount + p2.individualCount;
	//	return 1.0 - totalStrength / totalInd;
	//}
//	i1.evaluate();
	// spatial competition provides density-dependent selection
//	inds = p1.individuals;
//	competition = i1.totalOfNeighborStrengths(inds);
//	competition = (competition + 1) / (PI * S^2);
//	inds.fitnessScaling = K / competition;
//} 

1: late() {
	// construct phenotypes from the additive effects of QTLs
	inds = sim.subpopulations.individuals;
	phenotype = inds.sumOfMutationsOfType(m2);
	inds.z = phenotype;
	
	// color individuals according to phenotype
	inds.color = p1.spatialMapColor("map1", phenotype);
	
	//individual dispersal!!
	// move around a bit
	//for (ind in sim.subpopulations.individuals)
	//{
	//	do{
	//		newPos = ind.spatialPosition[0:1] + runif(2, -0.01, 0.01);
	//	}while (!p1.pointInBounds(c(newPos,ind.z)));
	//	ind.setSpatialPosition(c(newPos,ind.z));
	//}
	
	// evaluate interactions
	i1.evaluate();
	i2.evaluate();
}


late() {
	for (s in sim.subpopulations)
		if (s.individualCount == 0)
			stop("Population extinct, gen " + sim.generation + ".");
}


//Dynamic landscape
//need to fix how this is scaled
//1000: late()
//{
	//p2.setMigrationRates(p1, 0.1);

//	weight = (cos((sim.generation - 1) / rate_change) + 1.8) / 2.0;
//	newMap = weight * mapValues + (1 - weight) * 0.2;
//	p1.defineSpatialMap("map1", "xy", c(5, 5), newMap, interpolate=T,valueRange=c(-0.2, 1.2), colors=c("red", "yellow"));
//	p2.defineSpatialMap("map1", "xy", c(5, 5), newMap, interpolate=T,valueRange=c(-0.2, 1.2), colors=c("red", "yellow"));
//}

//fitness(m2) {      // make QTLs intrinsically neutral
//	return 1.0;
//}

//fitness(NULL) {    // reward proximity to the optimum
//	location = individual.spatialPosition[0:1];
//	optimum = subpop.spatialMapValue("map1", location);
//	return 1.0 + dnorm(optimum - individual.z, mean=0.0, sd=sigma_K);
//}

//fitness(NULL) {    // reward proximity to the pre-defined phenotypic optimum
//	location = individual.spatialPosition[0:1];
//	local = subpop.spatialMapValue("map1", location);
	
//	if (individual.subpopulation.id == 1)
//		return 1.0 + dnorm(p1_opt - local, mean=0.0, sd=sigma_K) * phen_weight;
//	else
//		return 1.0 + dnorm(p2_opt - local, mean=0.0, sd=sigma_K) * phen_weight;
//}

//fitness(NULL) {    // phenotypic competition
//	totalStrength = sum(i1.strength(individual));
//	totalInd = p1.individualCount + p2.individualCount;
//	return 1.0 - totalStrength / totalInd;
//}

//mateChoice() {
	// spatial mate choice
//	return i2.strength(individual);
//}

5000 late() {
	sim.simulationFinished();
}
